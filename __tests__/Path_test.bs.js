// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Jest = require("@glennsl/bs-jest/src/jest.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Path$KaroshibeeReTree = require("../src/Path.bs.js");
var Identity$KaroshibeeReTree = require("../src/Identity.bs.js");

Jest.describe("construction", (function (param) {
        var p = Path$KaroshibeeReTree.Parents.empty(/* () */0);
        Jest.test("rootOfEmptyIsNone", (function (param) {
                return Curry._2(Jest.Expect.Operators.$eq$eq, Jest.Expect.expect(Path$KaroshibeeReTree.Parents.root(p)), undefined);
              }));
        Jest.test("parentOfEmptyIsNone", (function (param) {
                return Curry._2(Jest.Expect.Operators.$eq$eq, Jest.Expect.expect(Path$KaroshibeeReTree.Parents.parent(p)), undefined);
              }));
        var p$1 = Path$KaroshibeeReTree.Parents.fromList(/* :: */[
              "parent",
              /* :: */[
                "root",
                /* [] */0
              ]
            ]);
        Jest.test("canMakeFromList", (function (param) {
                var id = Identity$KaroshibeeReTree.ParentId.create("parent");
                return Curry._2(Jest.Expect.Operators.$eq$eq, Jest.Expect.expect(Belt_Option.getExn(Path$KaroshibeeReTree.Parents.parent(p$1))), id);
              }));
        Jest.test("canMakeFromList1", (function (param) {
                var id = Identity$KaroshibeeReTree.ParentId.create("root");
                return Curry._2(Jest.Expect.Operators.$eq$eq, Jest.Expect.expect(Belt_Option.getExn(Path$KaroshibeeReTree.Parents.root(p$1))), id);
              }));
        var p$2 = Path$KaroshibeeReTree.Parents.fromList(/* :: */[
              "parent1",
              /* :: */[
                "parent2",
                /* :: */[
                  "root",
                  /* [] */0
                ]
              ]
            ]);
        Jest.test("pathUpToRoot", (function (param) {
                var ps = Belt_List.map(/* :: */[
                      "parent1",
                      /* :: */[
                        "parent2",
                        /* :: */[
                          "root",
                          /* [] */0
                        ]
                      ]
                    ], Identity$KaroshibeeReTree.ParentId.create);
                var qs = Path$KaroshibeeReTree.Parents.pathToRoot(p$2);
                var deepEq = function (prim, prim$1) {
                  return prim === prim$1;
                };
                return Jest.Expect.toBe(true, Jest.Expect.expect(Belt_List.eq(ps, qs, deepEq)));
              }));
        return Jest.test("pathFromRoot", (function (param) {
                      var ps = Belt_List.map(/* :: */[
                            "root",
                            /* :: */[
                              "parent2",
                              /* :: */[
                                "parent1",
                                /* [] */0
                              ]
                            ]
                          ], Identity$KaroshibeeReTree.ParentId.create);
                      var qs = Path$KaroshibeeReTree.Parents.pathFromRoot(p$2);
                      var deepEq = function (prim, prim$1) {
                        return prim === prim$1;
                      };
                      return Jest.Expect.toBe(true, Jest.Expect.expect(Belt_List.eq(ps, qs, deepEq)));
                    }));
      }));

Jest.describe("moving", (function (param) {
        Jest.test("canMoveUp", (function (param) {
                var p = Path$KaroshibeeReTree.Parents.fromList(/* :: */[
                      "parent1",
                      /* :: */[
                        "parent2",
                        /* :: */[
                          "root",
                          /* [] */0
                        ]
                      ]
                    ]);
                var pUp = Path$KaroshibeeReTree.Parents.fromList(/* :: */[
                      "parent2",
                      /* :: */[
                        "root",
                        /* [] */0
                      ]
                    ]);
                return Jest.Expect.toBe(true, Jest.Expect.expect(Path$KaroshibeeReTree.Parents.eq(Path$KaroshibeeReTree.Parents.moveUp(p), pUp)));
              }));
        Jest.test("canMoveUpEmpty", (function (param) {
                var p = Path$KaroshibeeReTree.Parents.empty(/* () */0);
                var pUp = Path$KaroshibeeReTree.Parents.fromList(/* [] */0);
                return Jest.Expect.toBe(true, Jest.Expect.expect(Path$KaroshibeeReTree.Parents.eq(Path$KaroshibeeReTree.Parents.moveUp(p), pUp)));
              }));
        Jest.test("canMoveDown", (function (param) {
                var p = Path$KaroshibeeReTree.Parents.fromList(/* :: */[
                      "parent1",
                      /* :: */[
                        "parent2",
                        /* :: */[
                          "root",
                          /* [] */0
                        ]
                      ]
                    ]);
                var pUp = Path$KaroshibeeReTree.Parents.fromList(/* :: */[
                      "parent1",
                      /* :: */[
                        "parent2",
                        /* [] */0
                      ]
                    ]);
                return Jest.Expect.toBe(true, Jest.Expect.expect(Path$KaroshibeeReTree.Parents.eq(Path$KaroshibeeReTree.Parents.moveDown(p), pUp)));
              }));
        return Jest.test("canMoveDownEmpty", (function (param) {
                      var p = Path$KaroshibeeReTree.Parents.empty(/* () */0);
                      var pUp = Path$KaroshibeeReTree.Parents.fromList(/* [] */0);
                      return Jest.Expect.toBe(true, Jest.Expect.expect(Path$KaroshibeeReTree.Parents.eq(Path$KaroshibeeReTree.Parents.moveDown(p), pUp)));
                    }));
      }));

Jest.describe("equality", (function (param) {
        Jest.test("samePath", (function (param) {
                var p = Path$KaroshibeeReTree.Parents.fromList(/* :: */[
                      "parent1",
                      /* :: */[
                        "parent2",
                        /* :: */[
                          "root",
                          /* [] */0
                        ]
                      ]
                    ]);
                var p2 = Path$KaroshibeeReTree.Parents.fromList(/* :: */[
                      "parent1",
                      /* :: */[
                        "parent2",
                        /* :: */[
                          "root",
                          /* [] */0
                        ]
                      ]
                    ]);
                return Jest.Expect.toBe(true, Jest.Expect.expect(Path$KaroshibeeReTree.Parents.eq(p, p2)));
              }));
        return Jest.test("notSamePath", (function (param) {
                      var p = Path$KaroshibeeReTree.Parents.fromList(/* :: */[
                            "parent1",
                            /* :: */[
                              "parent2",
                              /* :: */[
                                "root",
                                /* [] */0
                              ]
                            ]
                          ]);
                      var pUp = Path$KaroshibeeReTree.Parents.fromList(/* :: */[
                            "parent3",
                            /* :: */[
                              "root",
                              /* [] */0
                            ]
                          ]);
                      return Jest.Expect.toBe(false, Jest.Expect.expect(Path$KaroshibeeReTree.Parents.eq(p, pUp)));
                    }));
      }));

Jest.describe("append", (function (param) {
        var p = Path$KaroshibeeReTree.Parents.fromList(/* :: */[
              "parent1",
              /* :: */[
                "parent2",
                /* [] */0
              ]
            ]);
        var p1 = Path$KaroshibeeReTree.Parents.fromList(/* :: */[
              "child1",
              /* :: */[
                "parent1",
                /* :: */[
                  "parent2",
                  /* [] */0
                ]
              ]
            ]);
        return Jest.test("canAppend", (function (param) {
                      var q = Path$KaroshibeeReTree.Parents.append(p, Identity$KaroshibeeReTree.ParentId.create("child1"));
                      return Jest.Expect.toBe(true, Jest.Expect.expect(Path$KaroshibeeReTree.Parents.eq(q, p1)));
                    }));
      }));

Jest.describe("removeElement", (function (param) {
        var p = Path$KaroshibeeReTree.Parents.fromList(/* :: */[
              "child1",
              /* :: */[
                "parent1",
                /* :: */[
                  "parent2",
                  /* [] */0
                ]
              ]
            ]);
        var p1 = Path$KaroshibeeReTree.Parents.fromList(/* :: */[
              "child1",
              /* :: */[
                "parent2",
                /* [] */0
              ]
            ]);
        return Jest.test("canRemove", (function (param) {
                      var q = Path$KaroshibeeReTree.Parents.removeElement(p, Identity$KaroshibeeReTree.ParentId.create("parent1"));
                      return Jest.Expect.toBe(true, Jest.Expect.expect(Path$KaroshibeeReTree.Parents.eq(q, p1)));
                    }));
      }));

Jest.describe("concat", (function (param) {
        var p = Path$KaroshibeeReTree.Parents.fromList(/* :: */[
              "child1",
              /* :: */[
                "parent1",
                /* :: */[
                  "parent2",
                  /* [] */0
                ]
              ]
            ]);
        var p1 = Path$KaroshibeeReTree.Parents.fromList(/* :: */[
              "parent3",
              /* :: */[
                "parent4",
                /* [] */0
              ]
            ]);
        var p2 = Path$KaroshibeeReTree.Parents.fromList(/* :: */[
              "child1",
              /* :: */[
                "parent1",
                /* :: */[
                  "parent2",
                  /* :: */[
                    "parent3",
                    /* :: */[
                      "parent4",
                      /* [] */0
                    ]
                  ]
                ]
              ]
            ]);
        return Jest.test("canConcat", (function (param) {
                      var q = Path$KaroshibeeReTree.Parents.concat(p, p1);
                      return Jest.Expect.toBe(true, Jest.Expect.expect(Path$KaroshibeeReTree.Parents.eq(q, p2)));
                    }));
      }));

var M = /* alias */0;

exports.M = M;
/*  Not a pure module */
